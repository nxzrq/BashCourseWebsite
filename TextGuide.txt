###################################################
# The Ultimate Beginner's Guide to Bash Scripting #
###################################################

Welcome to your comprehensive guide to learning Bash scripting. This guide is designed for beginners and will walk you through all the fundamental concepts you need to start automating tasks and writing your own powerful scripts.

================================
# Chapter 1: Getting Started #
================================

---
### What is a Shell? What is Bash?
---

A **shell** is a command-line interface (CLI) that allows you to interact with your operating system. You type commands, and the shell executes them.

**Bash** (Bourne Again SHell) is one of the most popular and widely used shells, especially on Linux and macOS. A **Bash script** is simply a plain text file containing a series of Bash commands that are executed in order.

---
### Your First Script: Hello, World!
---

Let's create our first script.

1.  **Create the file:**
    Open a terminal and type `touch hello_world.sh`. This creates an empty file.

2.  **Add the code:**
    Open the file in a text editor and add the following lines:

    ```bash
    #!/bin/bash

    # This is a comment. The line below will print "Hello, World!"
    echo "Hello, World!"
    ```

3.  **Understand the code:**
    *   **`#!/bin/bash`** (The Shebang): This is a special line that tells the operating system which interpreter to use to run the script (in this case, Bash). It should always be the very first line of your script.
    *   **`#`** (Comments): Any line starting with a `#` is a comment. The shell ignores it. Use comments to explain your code.
    *   **`echo`**: This is a built-in command that prints text to the terminal.

---
### Making a Script Executable and Running It
---

Right now, `hello_world.sh` is just a text file. To run it as a program, you need to give it "execute" permissions.

1.  **Add Execute Permission:**
    In the terminal, run the following command:
    *   **`chmod +x hello_world.sh`**
        (`chmod` means "change mode", `+x` means "add execute permission")

2.  **Run the Script:**
    You can now run your script by typing its path:
    *   **`./hello_world.sh`**
        (`./` refers to the current directory)

    You should see "Hello, World!" printed to your screen.

=========================================
# Chapter 2: Variables and User Input #
=========================================

---
### `Variables`
---

Variables store data. In Bash, you define a variable by giving it a name and a value.

**Rules:**
*   No spaces around the equals sign (`=`).
*   Variable names are typically in `UPPERCASE` by convention.
*   To get the value of a variable, you prefix its name with a dollar sign (`$`).

**Example:**

```bash
#!/bin/bash

# Variable declaration
GREETING="Hello"
USER="testprofile"

# Using the variables
echo "$GREETING, $USER!" # Use double quotes to allow variable expansion

# Using curly braces is a good practice to avoid ambiguity
echo "I am ${USER}."
```

---
### `Command Substitution`
---

You can store the output of a command in a variable. This is called command substitution.

**Example:**

```bash
#!/bin/bash

CURRENT_DIRECTORY=$(pwd)
FILE_LIST=$(ls)

echo "You are currently in: ${CURRENT_DIRECTORY}"
echo "The files here are: ${FILE_LIST}"
```

---
### Reading User Input with `read`
---

You can make your scripts interactive by asking the user for input.

**Example:**

```bash
#!/bin/bash

# -p shows a prompt to the user
# The input is stored in the NAME variable
read -p "Please enter your name: " NAME

echo "Welcome, ${NAME}!"
```

==================================
# Chapter 3: Positional Parameters #
==================================

Positional parameters allow you to pass arguments to your script when you run it from the command line.

*   `$0`: The name of the script itself.
*   `$1`: The first argument.
*   `$2`: The second argument.
*   `...` and so on.
*   `$#`: The total number of arguments passed.
*   `$@`: All arguments passed, treated as separate strings (this is usually what you want).

**Example:**
Save this as `user_info.sh`, make it executable, and run it like `./user_info.sh Alice 30`.

```bash
#!/bin/bash

# Arguments are assigned to variables for clarity
NAME=$1
AGE=$2

echo "Script name: $0"
echo "Hello, ${NAME}. You are ${AGE} years old."
echo "Total number of arguments: $#"
```

================================
# Chapter 4: Conditional Logic #
================================

Conditional logic allows your script to make decisions.

---
### The `if` Statement
---

The `if` statement checks if a condition is true and executes code if it is. The condition goes inside square brackets `[ ... ]`. **Note the mandatory spaces inside the brackets!**

**String Comparison:**
*   `"string1" == "string2"`: True if strings are equal.
*   `"string1" != "string2"`: True if strings are not equal.
*   `-z "string"`: True if the string is empty.
*   `-n "string"`: True if the string is not empty.

**Example:**

```bash
#!/bin/bash

read -p "What is your name? " NAME

if [ "${NAME}" == "Alice" ]; then
  echo "Welcome, Alice!"
fi
```

---
### The `if-else` and `if-elif-else` Statements
---

*   `else`: Executes code if the `if` condition is false.
*   `elif` (else if): Checks another condition if the first one is false.

**Example:**

```bash
#!/bin/bash

read -p "Enter a number: " NUM

if [ "${NUM}" -gt 100 ]; then
  echo "That's a big number."
elif [ "${NUM}" -eq 42 ]; then
  echo "That's the answer to everything!"
else
  echo "That's a small number."
fi
```

---
### Integer and File Conditions
---

**Integer Comparison:**
*   `-eq`: equal
*   `-ne`: not equal
*   `-gt`: greater than
*   `-lt`: less than
*   `-ge`: greater than or equal to
*   `-le`: less than or equal to

**File System Checks:**
*   `-f "file"`: True if it's a file.
*   `-d "dir"`: True if it's a directory.
*   `-e "path"`: True if the path exists (file or directory).

**Example:**

```bash
#!/bin/bash

FILE_PATH="./my_file.txt"

if [ -f "${FILE_PATH}" ]; then
  echo "The file exists."
else
  echo "The file does not exist."
fi
```

---
### The `case` Statement
---

A `case` statement is a cleaner way to handle multiple choices, similar to a `switch` statement in other languages.

**Example:**

```bash
#!/bin/bash

read -p "Enter 'start', 'stop', or 'status': " COMMAND

case $COMMAND in
  "start")
    echo "Starting the service..."
    ;;
  "stop")
    echo "Stopping the service..."
    ;;
  "status")
    echo "Checking the status..."
    ;;
  *) # The wildcard for "anything else"
    echo "Unknown command."
    ;;
esac
```

=================
# Chapter 5: Loops #
=================

Loops allow you to execute a block of code multiple times.

---
### The `for` Loop
---

A `for` loop iterates over a list of items.

**Example 1: Looping over a list of strings**
```bash
#!/bin/bash

for PLANET in Mercury Venus Earth Mars Jupiter; do
  echo "Planet: ${PLANET}"
done
```

**Example 2: Looping over a range of numbers**
```bash
#!/bin/bash

for i in {1..5}; do
  echo "Iteration number: ${i}"
done
```

---
### The `while` Loop
---

A `while` loop continues as long as a condition is true.

**Example:**

```bash
#!/bin/bash

COUNTER=1

while [ ${COUNTER} -le 5 ]; do
  echo "Counter is at: ${COUNTER}"
  # Increment the counter
  COUNTER=$((COUNTER + 1))
done
```
*   **`$((...))`**: This is the syntax for arithmetic expansion.

---
### The `until` Loop
---

An `until` loop is the opposite of a `while` loop. It continues as long as a condition is false.

**Example:**

```bash
#!/bin/bash

COUNTER=1

until [ ${COUNTER} -gt 5 ]; do
  echo "Counter is at: ${COUNTER}"
  COUNTER=$((COUNTER + 1))
done
```

---
### Loop Control: `break` and `continue`
---

*   **`break`**: Exits the loop immediately.
*   **`continue`**: Skips the current iteration and starts the next one.

**Example:**

```bash
#!/bin/bash

for i in {1..10}; do
  if [ ${i} -eq 3 ]; then
    continue # Skip printing 3
  fi
  if [ ${i} -eq 8 ]; then
    break # Stop the loop when we get to 8
  fi
  echo ${i}
done
```

=====================
# Chapter 6: Functions #
=====================

Functions are reusable blocks of code. They help you organize your script and avoid repetition.

---
### Defining and Calling Functions
---

**Example:**

```bash
#!/bin/bash

# Define the function
function greet() {
  echo "Hello from the greet function!"
}

# Call the function
echo "About to call the function..."
greet
echo "Function has been called."
```

---
### Passing Arguments to Functions
---

Functions can accept arguments, just like scripts can. Inside the function, you access them with `$1`, `$2`, etc.

**Example:**

```bash
#!/bin/bash

function greet_user() {
  local USER_NAME=$1 # Use 'local' to keep the variable inside the function
  echo "Hello, ${USER_NAME}!"
}

greet_user "Alice"
greet_user "Bob"
```

---
### Returning Values from Functions
---

Bash functions don't have a traditional `return` statement for values. They have two main ways of "returning" something:

1.  **Return Status (Exit Code):** The `return` keyword sets the function's exit status (a number between 0 and 255). `0` means success, and any other number means failure. This is useful for checking if a function succeeded.

2.  **Standard Output:** To return a value (like a string or number), you simply `echo` it from the function and capture it with command substitution `$(...)`.

**Example:**

```bash
#!/bin/bash

function get_full_name() {
  local FIRST_NAME=$1
  local LAST_NAME=$2
  # "Return" the value by printing it to standard output
  echo "${FIRST_NAME} ${LAST_NAME}"
}

# Capture the "returned" value in a variable
FULL_NAME=$(get_full_name "John" "Doe")

echo "The full name is: ${FULL_NAME}"
```

================================
# Chapter 7: Practical Example #
================================

Let's create a simple backup script that combines many of these concepts. This script will create a compressed archive of a directory.

**`simple_backup.sh`**

```bash
#!/bin/bash

# A simple backup script

# Function to display how to use the script
function display_usage() {
  echo "Usage: $0 <directory_to_backup>"
  echo "Example: $0 /home/user/documents"
}

# --- Main Script Logic ---

# 1. Check if an argument was provided
if [ $# -eq 0 ]; then
  echo "Error: No directory specified."
  display_usage
  exit 1 # Exit with an error code
fi

# 2. Check if the specified directory exists
DIRECTORY_TO_BACKUP=$1

if [ ! -d "${DIRECTORY_TO_BACKUP}" ]; then
  echo "Error: Directory '${DIRECTORY_TO_BACKUP}' does not exist."
  exit 1
fi

# 3. Create a filename with a timestamp
TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
# basename gets the directory name from the path
FILENAME="backup_${TIMESTAMP}_$(basename ${DIRECTORY_TO_BACKUP}).tar.gz"

# 4. Create the backup
echo "Backing up '${DIRECTORY_TO_BACKUP}' to '${FILENAME}'..."
# tar is a command to create archives
# -c: create
# -z: compress with gzip
# -f: specify filename
tar -czf "${FILENAME}" "${DIRECTORY_TO_BACKUP}"

# 5. Confirm completion
if [ $? -eq 0 ]; then
  echo "Backup created successfully!"
else
  echo "Error: Backup failed."
fi

# $? is a special variable that holds the exit code of the last command
```

This concludes the beginner's guide. Keep practicing, and you'll be writing complex and useful scripts in no time!
